/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../../common";

export declare namespace Tick {
  export type InfoStruct = {
    liquidityGross: BigNumberish;
    liquidityNet: BigNumberish;
    feeGrowthOutside0X128: BigNumberish;
    feeGrowthOutside1X128: BigNumberish;
    tickCumulativeOutside: BigNumberish;
    secondsPerLiquidityOutsideX128: BigNumberish;
    secondsOutside: BigNumberish;
    initialized: boolean;
  };

  export type InfoStructOutput = [
    liquidityGross: bigint,
    liquidityNet: bigint,
    feeGrowthOutside0X128: bigint,
    feeGrowthOutside1X128: bigint,
    tickCumulativeOutside: bigint,
    secondsPerLiquidityOutsideX128: bigint,
    secondsOutside: bigint,
    initialized: boolean
  ] & {
    liquidityGross: bigint;
    liquidityNet: bigint;
    feeGrowthOutside0X128: bigint;
    feeGrowthOutside1X128: bigint;
    tickCumulativeOutside: bigint;
    secondsPerLiquidityOutsideX128: bigint;
    secondsOutside: bigint;
    initialized: boolean;
  };
}

export interface TickTestInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "clear"
      | "cross"
      | "getFeeGrowthInside"
      | "setTick"
      | "tickSpacingToMaxLiquidityPerTick"
      | "ticks"
      | "update"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "clear", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "cross",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getFeeGrowthInside",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setTick",
    values: [BigNumberish, Tick.InfoStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "tickSpacingToMaxLiquidityPerTick",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "ticks", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "update",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      boolean,
      BigNumberish
    ]
  ): string;

  decodeFunctionResult(functionFragment: "clear", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "cross", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getFeeGrowthInside",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setTick", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tickSpacingToMaxLiquidityPerTick",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "ticks", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "update", data: BytesLike): Result;
}

export interface TickTest extends BaseContract {
  connect(runner?: ContractRunner | null): TickTest;
  waitForDeployment(): Promise<this>;

  interface: TickTestInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  clear: TypedContractMethod<[tick: BigNumberish], [void], "nonpayable">;

  cross: TypedContractMethod<
    [
      tick: BigNumberish,
      feeGrowthGlobal0X128: BigNumberish,
      feeGrowthGlobal1X128: BigNumberish,
      secondsPerLiquidityCumulativeX128: BigNumberish,
      tickCumulative: BigNumberish,
      time: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  getFeeGrowthInside: TypedContractMethod<
    [
      tickLower: BigNumberish,
      tickUpper: BigNumberish,
      tickCurrent: BigNumberish,
      feeGrowthGlobal0X128: BigNumberish,
      feeGrowthGlobal1X128: BigNumberish
    ],
    [
      [bigint, bigint] & {
        feeGrowthInside0X128: bigint;
        feeGrowthInside1X128: bigint;
      }
    ],
    "view"
  >;

  setTick: TypedContractMethod<
    [tick: BigNumberish, info: Tick.InfoStruct],
    [void],
    "nonpayable"
  >;

  tickSpacingToMaxLiquidityPerTick: TypedContractMethod<
    [tickSpacing: BigNumberish],
    [bigint],
    "view"
  >;

  ticks: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, bigint, bigint, bigint, bigint, bigint, bigint, boolean] & {
        liquidityGross: bigint;
        liquidityNet: bigint;
        feeGrowthOutside0X128: bigint;
        feeGrowthOutside1X128: bigint;
        tickCumulativeOutside: bigint;
        secondsPerLiquidityOutsideX128: bigint;
        secondsOutside: bigint;
        initialized: boolean;
      }
    ],
    "view"
  >;

  update: TypedContractMethod<
    [
      tick: BigNumberish,
      tickCurrent: BigNumberish,
      liquidityDelta: BigNumberish,
      feeGrowthGlobal0X128: BigNumberish,
      feeGrowthGlobal1X128: BigNumberish,
      secondsPerLiquidityCumulativeX128: BigNumberish,
      tickCumulative: BigNumberish,
      time: BigNumberish,
      upper: boolean,
      maxLiquidity: BigNumberish
    ],
    [boolean],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "clear"
  ): TypedContractMethod<[tick: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "cross"
  ): TypedContractMethod<
    [
      tick: BigNumberish,
      feeGrowthGlobal0X128: BigNumberish,
      feeGrowthGlobal1X128: BigNumberish,
      secondsPerLiquidityCumulativeX128: BigNumberish,
      tickCumulative: BigNumberish,
      time: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "getFeeGrowthInside"
  ): TypedContractMethod<
    [
      tickLower: BigNumberish,
      tickUpper: BigNumberish,
      tickCurrent: BigNumberish,
      feeGrowthGlobal0X128: BigNumberish,
      feeGrowthGlobal1X128: BigNumberish
    ],
    [
      [bigint, bigint] & {
        feeGrowthInside0X128: bigint;
        feeGrowthInside1X128: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "setTick"
  ): TypedContractMethod<
    [tick: BigNumberish, info: Tick.InfoStruct],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "tickSpacingToMaxLiquidityPerTick"
  ): TypedContractMethod<[tickSpacing: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "ticks"
  ): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, bigint, bigint, bigint, bigint, bigint, bigint, boolean] & {
        liquidityGross: bigint;
        liquidityNet: bigint;
        feeGrowthOutside0X128: bigint;
        feeGrowthOutside1X128: bigint;
        tickCumulativeOutside: bigint;
        secondsPerLiquidityOutsideX128: bigint;
        secondsOutside: bigint;
        initialized: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "update"
  ): TypedContractMethod<
    [
      tick: BigNumberish,
      tickCurrent: BigNumberish,
      liquidityDelta: BigNumberish,
      feeGrowthGlobal0X128: BigNumberish,
      feeGrowthGlobal1X128: BigNumberish,
      secondsPerLiquidityCumulativeX128: BigNumberish,
      tickCumulative: BigNumberish,
      time: BigNumberish,
      upper: boolean,
      maxLiquidity: BigNumberish
    ],
    [boolean],
    "nonpayable"
  >;

  filters: {};
}
