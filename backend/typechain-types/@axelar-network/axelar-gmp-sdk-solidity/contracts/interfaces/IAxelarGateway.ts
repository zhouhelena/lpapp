/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../../../common";

export interface IAxelarGatewayInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "allTokensFrozen"
      | "authModule"
      | "callContract"
      | "callContractWithToken"
      | "contractId"
      | "execute"
      | "governance"
      | "implementation"
      | "isCommandExecuted"
      | "isContractCallAndMintApproved"
      | "isContractCallApproved"
      | "mintLimiter"
      | "sendToken"
      | "setTokenMintLimits"
      | "setup"
      | "tokenAddresses"
      | "tokenDeployer"
      | "tokenFrozen"
      | "tokenMintAmount"
      | "tokenMintLimit"
      | "transferGovernance"
      | "transferMintLimiter"
      | "upgrade"
      | "validateContractCall"
      | "validateContractCallAndMint"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "ContractCall"
      | "ContractCallApproved"
      | "ContractCallApprovedWithMint"
      | "ContractCallExecuted"
      | "ContractCallWithToken"
      | "Executed"
      | "GovernanceTransferred"
      | "MintLimiterTransferred"
      | "OperatorshipTransferred"
      | "TokenDeployed"
      | "TokenMintLimitUpdated"
      | "TokenSent"
      | "Upgraded"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "allTokensFrozen",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "authModule",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "callContract",
    values: [string, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "callContractWithToken",
    values: [string, string, BytesLike, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "contractId",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "execute", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "governance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "implementation",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isCommandExecuted",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isContractCallAndMintApproved",
    values: [
      BytesLike,
      string,
      string,
      AddressLike,
      BytesLike,
      string,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isContractCallApproved",
    values: [BytesLike, string, string, AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "mintLimiter",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "sendToken",
    values: [string, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setTokenMintLimits",
    values: [string[], BigNumberish[]]
  ): string;
  encodeFunctionData(functionFragment: "setup", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "tokenAddresses",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenDeployer",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "tokenFrozen", values: [string]): string;
  encodeFunctionData(
    functionFragment: "tokenMintAmount",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenMintLimit",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "transferGovernance",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferMintLimiter",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "upgrade",
    values: [AddressLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "validateContractCall",
    values: [BytesLike, string, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "validateContractCallAndMint",
    values: [BytesLike, string, string, BytesLike, string, BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "allTokensFrozen",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "authModule", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "callContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "callContractWithToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "contractId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "execute", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "governance", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "implementation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isCommandExecuted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isContractCallAndMintApproved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isContractCallApproved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "mintLimiter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sendToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setTokenMintLimits",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setup", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tokenAddresses",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenDeployer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenFrozen",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenMintAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenMintLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferGovernance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferMintLimiter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "upgrade", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "validateContractCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validateContractCallAndMint",
    data: BytesLike
  ): Result;
}

export namespace ContractCallEvent {
  export type InputTuple = [
    sender: AddressLike,
    destinationChain: string,
    destinationContractAddress: string,
    payloadHash: BytesLike,
    payload: BytesLike
  ];
  export type OutputTuple = [
    sender: string,
    destinationChain: string,
    destinationContractAddress: string,
    payloadHash: string,
    payload: string
  ];
  export interface OutputObject {
    sender: string;
    destinationChain: string;
    destinationContractAddress: string;
    payloadHash: string;
    payload: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ContractCallApprovedEvent {
  export type InputTuple = [
    commandId: BytesLike,
    sourceChain: string,
    sourceAddress: string,
    contractAddress: AddressLike,
    payloadHash: BytesLike,
    sourceTxHash: BytesLike,
    sourceEventIndex: BigNumberish
  ];
  export type OutputTuple = [
    commandId: string,
    sourceChain: string,
    sourceAddress: string,
    contractAddress: string,
    payloadHash: string,
    sourceTxHash: string,
    sourceEventIndex: bigint
  ];
  export interface OutputObject {
    commandId: string;
    sourceChain: string;
    sourceAddress: string;
    contractAddress: string;
    payloadHash: string;
    sourceTxHash: string;
    sourceEventIndex: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ContractCallApprovedWithMintEvent {
  export type InputTuple = [
    commandId: BytesLike,
    sourceChain: string,
    sourceAddress: string,
    contractAddress: AddressLike,
    payloadHash: BytesLike,
    symbol: string,
    amount: BigNumberish,
    sourceTxHash: BytesLike,
    sourceEventIndex: BigNumberish
  ];
  export type OutputTuple = [
    commandId: string,
    sourceChain: string,
    sourceAddress: string,
    contractAddress: string,
    payloadHash: string,
    symbol: string,
    amount: bigint,
    sourceTxHash: string,
    sourceEventIndex: bigint
  ];
  export interface OutputObject {
    commandId: string;
    sourceChain: string;
    sourceAddress: string;
    contractAddress: string;
    payloadHash: string;
    symbol: string;
    amount: bigint;
    sourceTxHash: string;
    sourceEventIndex: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ContractCallExecutedEvent {
  export type InputTuple = [commandId: BytesLike];
  export type OutputTuple = [commandId: string];
  export interface OutputObject {
    commandId: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ContractCallWithTokenEvent {
  export type InputTuple = [
    sender: AddressLike,
    destinationChain: string,
    destinationContractAddress: string,
    payloadHash: BytesLike,
    payload: BytesLike,
    symbol: string,
    amount: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    destinationChain: string,
    destinationContractAddress: string,
    payloadHash: string,
    payload: string,
    symbol: string,
    amount: bigint
  ];
  export interface OutputObject {
    sender: string;
    destinationChain: string;
    destinationContractAddress: string;
    payloadHash: string;
    payload: string;
    symbol: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ExecutedEvent {
  export type InputTuple = [commandId: BytesLike];
  export type OutputTuple = [commandId: string];
  export interface OutputObject {
    commandId: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace GovernanceTransferredEvent {
  export type InputTuple = [
    previousGovernance: AddressLike,
    newGovernance: AddressLike
  ];
  export type OutputTuple = [previousGovernance: string, newGovernance: string];
  export interface OutputObject {
    previousGovernance: string;
    newGovernance: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MintLimiterTransferredEvent {
  export type InputTuple = [
    previousGovernance: AddressLike,
    newGovernance: AddressLike
  ];
  export type OutputTuple = [previousGovernance: string, newGovernance: string];
  export interface OutputObject {
    previousGovernance: string;
    newGovernance: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OperatorshipTransferredEvent {
  export type InputTuple = [newOperatorsData: BytesLike];
  export type OutputTuple = [newOperatorsData: string];
  export interface OutputObject {
    newOperatorsData: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TokenDeployedEvent {
  export type InputTuple = [symbol: string, tokenAddresses: AddressLike];
  export type OutputTuple = [symbol: string, tokenAddresses: string];
  export interface OutputObject {
    symbol: string;
    tokenAddresses: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TokenMintLimitUpdatedEvent {
  export type InputTuple = [symbol: string, limit: BigNumberish];
  export type OutputTuple = [symbol: string, limit: bigint];
  export interface OutputObject {
    symbol: string;
    limit: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TokenSentEvent {
  export type InputTuple = [
    sender: AddressLike,
    destinationChain: string,
    destinationAddress: string,
    symbol: string,
    amount: BigNumberish
  ];
  export type OutputTuple = [
    sender: string,
    destinationChain: string,
    destinationAddress: string,
    symbol: string,
    amount: bigint
  ];
  export interface OutputObject {
    sender: string;
    destinationChain: string;
    destinationAddress: string;
    symbol: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UpgradedEvent {
  export type InputTuple = [implementation: AddressLike];
  export type OutputTuple = [implementation: string];
  export interface OutputObject {
    implementation: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface IAxelarGateway extends BaseContract {
  connect(runner?: ContractRunner | null): IAxelarGateway;
  waitForDeployment(): Promise<this>;

  interface: IAxelarGatewayInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  allTokensFrozen: TypedContractMethod<[], [boolean], "view">;

  authModule: TypedContractMethod<[], [string], "view">;

  callContract: TypedContractMethod<
    [destinationChain: string, contractAddress: string, payload: BytesLike],
    [void],
    "nonpayable"
  >;

  callContractWithToken: TypedContractMethod<
    [
      destinationChain: string,
      contractAddress: string,
      payload: BytesLike,
      symbol: string,
      amount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  contractId: TypedContractMethod<[], [string], "view">;

  execute: TypedContractMethod<[input: BytesLike], [void], "nonpayable">;

  governance: TypedContractMethod<[], [string], "view">;

  implementation: TypedContractMethod<[], [string], "view">;

  isCommandExecuted: TypedContractMethod<
    [commandId: BytesLike],
    [boolean],
    "view"
  >;

  isContractCallAndMintApproved: TypedContractMethod<
    [
      commandId: BytesLike,
      sourceChain: string,
      sourceAddress: string,
      contractAddress: AddressLike,
      payloadHash: BytesLike,
      symbol: string,
      amount: BigNumberish
    ],
    [boolean],
    "view"
  >;

  isContractCallApproved: TypedContractMethod<
    [
      commandId: BytesLike,
      sourceChain: string,
      sourceAddress: string,
      contractAddress: AddressLike,
      payloadHash: BytesLike
    ],
    [boolean],
    "view"
  >;

  mintLimiter: TypedContractMethod<[], [string], "view">;

  sendToken: TypedContractMethod<
    [
      destinationChain: string,
      destinationAddress: string,
      symbol: string,
      amount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  setTokenMintLimits: TypedContractMethod<
    [symbols: string[], limits: BigNumberish[]],
    [void],
    "nonpayable"
  >;

  setup: TypedContractMethod<[data: BytesLike], [void], "nonpayable">;

  tokenAddresses: TypedContractMethod<[symbol: string], [string], "view">;

  tokenDeployer: TypedContractMethod<[], [string], "view">;

  tokenFrozen: TypedContractMethod<[symbol: string], [boolean], "view">;

  tokenMintAmount: TypedContractMethod<[symbol: string], [bigint], "view">;

  tokenMintLimit: TypedContractMethod<[symbol: string], [bigint], "view">;

  transferGovernance: TypedContractMethod<
    [newGovernance: AddressLike],
    [void],
    "nonpayable"
  >;

  transferMintLimiter: TypedContractMethod<
    [newGovernance: AddressLike],
    [void],
    "nonpayable"
  >;

  upgrade: TypedContractMethod<
    [
      newImplementation: AddressLike,
      newImplementationCodeHash: BytesLike,
      setupParams: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  validateContractCall: TypedContractMethod<
    [
      commandId: BytesLike,
      sourceChain: string,
      sourceAddress: string,
      payloadHash: BytesLike
    ],
    [boolean],
    "nonpayable"
  >;

  validateContractCallAndMint: TypedContractMethod<
    [
      commandId: BytesLike,
      sourceChain: string,
      sourceAddress: string,
      payloadHash: BytesLike,
      symbol: string,
      amount: BigNumberish
    ],
    [boolean],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "allTokensFrozen"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "authModule"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "callContract"
  ): TypedContractMethod<
    [destinationChain: string, contractAddress: string, payload: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "callContractWithToken"
  ): TypedContractMethod<
    [
      destinationChain: string,
      contractAddress: string,
      payload: BytesLike,
      symbol: string,
      amount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "contractId"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "execute"
  ): TypedContractMethod<[input: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "governance"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "implementation"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "isCommandExecuted"
  ): TypedContractMethod<[commandId: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "isContractCallAndMintApproved"
  ): TypedContractMethod<
    [
      commandId: BytesLike,
      sourceChain: string,
      sourceAddress: string,
      contractAddress: AddressLike,
      payloadHash: BytesLike,
      symbol: string,
      amount: BigNumberish
    ],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "isContractCallApproved"
  ): TypedContractMethod<
    [
      commandId: BytesLike,
      sourceChain: string,
      sourceAddress: string,
      contractAddress: AddressLike,
      payloadHash: BytesLike
    ],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "mintLimiter"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "sendToken"
  ): TypedContractMethod<
    [
      destinationChain: string,
      destinationAddress: string,
      symbol: string,
      amount: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setTokenMintLimits"
  ): TypedContractMethod<
    [symbols: string[], limits: BigNumberish[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setup"
  ): TypedContractMethod<[data: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "tokenAddresses"
  ): TypedContractMethod<[symbol: string], [string], "view">;
  getFunction(
    nameOrSignature: "tokenDeployer"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "tokenFrozen"
  ): TypedContractMethod<[symbol: string], [boolean], "view">;
  getFunction(
    nameOrSignature: "tokenMintAmount"
  ): TypedContractMethod<[symbol: string], [bigint], "view">;
  getFunction(
    nameOrSignature: "tokenMintLimit"
  ): TypedContractMethod<[symbol: string], [bigint], "view">;
  getFunction(
    nameOrSignature: "transferGovernance"
  ): TypedContractMethod<[newGovernance: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "transferMintLimiter"
  ): TypedContractMethod<[newGovernance: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "upgrade"
  ): TypedContractMethod<
    [
      newImplementation: AddressLike,
      newImplementationCodeHash: BytesLike,
      setupParams: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "validateContractCall"
  ): TypedContractMethod<
    [
      commandId: BytesLike,
      sourceChain: string,
      sourceAddress: string,
      payloadHash: BytesLike
    ],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "validateContractCallAndMint"
  ): TypedContractMethod<
    [
      commandId: BytesLike,
      sourceChain: string,
      sourceAddress: string,
      payloadHash: BytesLike,
      symbol: string,
      amount: BigNumberish
    ],
    [boolean],
    "nonpayable"
  >;

  getEvent(
    key: "ContractCall"
  ): TypedContractEvent<
    ContractCallEvent.InputTuple,
    ContractCallEvent.OutputTuple,
    ContractCallEvent.OutputObject
  >;
  getEvent(
    key: "ContractCallApproved"
  ): TypedContractEvent<
    ContractCallApprovedEvent.InputTuple,
    ContractCallApprovedEvent.OutputTuple,
    ContractCallApprovedEvent.OutputObject
  >;
  getEvent(
    key: "ContractCallApprovedWithMint"
  ): TypedContractEvent<
    ContractCallApprovedWithMintEvent.InputTuple,
    ContractCallApprovedWithMintEvent.OutputTuple,
    ContractCallApprovedWithMintEvent.OutputObject
  >;
  getEvent(
    key: "ContractCallExecuted"
  ): TypedContractEvent<
    ContractCallExecutedEvent.InputTuple,
    ContractCallExecutedEvent.OutputTuple,
    ContractCallExecutedEvent.OutputObject
  >;
  getEvent(
    key: "ContractCallWithToken"
  ): TypedContractEvent<
    ContractCallWithTokenEvent.InputTuple,
    ContractCallWithTokenEvent.OutputTuple,
    ContractCallWithTokenEvent.OutputObject
  >;
  getEvent(
    key: "Executed"
  ): TypedContractEvent<
    ExecutedEvent.InputTuple,
    ExecutedEvent.OutputTuple,
    ExecutedEvent.OutputObject
  >;
  getEvent(
    key: "GovernanceTransferred"
  ): TypedContractEvent<
    GovernanceTransferredEvent.InputTuple,
    GovernanceTransferredEvent.OutputTuple,
    GovernanceTransferredEvent.OutputObject
  >;
  getEvent(
    key: "MintLimiterTransferred"
  ): TypedContractEvent<
    MintLimiterTransferredEvent.InputTuple,
    MintLimiterTransferredEvent.OutputTuple,
    MintLimiterTransferredEvent.OutputObject
  >;
  getEvent(
    key: "OperatorshipTransferred"
  ): TypedContractEvent<
    OperatorshipTransferredEvent.InputTuple,
    OperatorshipTransferredEvent.OutputTuple,
    OperatorshipTransferredEvent.OutputObject
  >;
  getEvent(
    key: "TokenDeployed"
  ): TypedContractEvent<
    TokenDeployedEvent.InputTuple,
    TokenDeployedEvent.OutputTuple,
    TokenDeployedEvent.OutputObject
  >;
  getEvent(
    key: "TokenMintLimitUpdated"
  ): TypedContractEvent<
    TokenMintLimitUpdatedEvent.InputTuple,
    TokenMintLimitUpdatedEvent.OutputTuple,
    TokenMintLimitUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "TokenSent"
  ): TypedContractEvent<
    TokenSentEvent.InputTuple,
    TokenSentEvent.OutputTuple,
    TokenSentEvent.OutputObject
  >;
  getEvent(
    key: "Upgraded"
  ): TypedContractEvent<
    UpgradedEvent.InputTuple,
    UpgradedEvent.OutputTuple,
    UpgradedEvent.OutputObject
  >;

  filters: {
    "ContractCall(address,string,string,bytes32,bytes)": TypedContractEvent<
      ContractCallEvent.InputTuple,
      ContractCallEvent.OutputTuple,
      ContractCallEvent.OutputObject
    >;
    ContractCall: TypedContractEvent<
      ContractCallEvent.InputTuple,
      ContractCallEvent.OutputTuple,
      ContractCallEvent.OutputObject
    >;

    "ContractCallApproved(bytes32,string,string,address,bytes32,bytes32,uint256)": TypedContractEvent<
      ContractCallApprovedEvent.InputTuple,
      ContractCallApprovedEvent.OutputTuple,
      ContractCallApprovedEvent.OutputObject
    >;
    ContractCallApproved: TypedContractEvent<
      ContractCallApprovedEvent.InputTuple,
      ContractCallApprovedEvent.OutputTuple,
      ContractCallApprovedEvent.OutputObject
    >;

    "ContractCallApprovedWithMint(bytes32,string,string,address,bytes32,string,uint256,bytes32,uint256)": TypedContractEvent<
      ContractCallApprovedWithMintEvent.InputTuple,
      ContractCallApprovedWithMintEvent.OutputTuple,
      ContractCallApprovedWithMintEvent.OutputObject
    >;
    ContractCallApprovedWithMint: TypedContractEvent<
      ContractCallApprovedWithMintEvent.InputTuple,
      ContractCallApprovedWithMintEvent.OutputTuple,
      ContractCallApprovedWithMintEvent.OutputObject
    >;

    "ContractCallExecuted(bytes32)": TypedContractEvent<
      ContractCallExecutedEvent.InputTuple,
      ContractCallExecutedEvent.OutputTuple,
      ContractCallExecutedEvent.OutputObject
    >;
    ContractCallExecuted: TypedContractEvent<
      ContractCallExecutedEvent.InputTuple,
      ContractCallExecutedEvent.OutputTuple,
      ContractCallExecutedEvent.OutputObject
    >;

    "ContractCallWithToken(address,string,string,bytes32,bytes,string,uint256)": TypedContractEvent<
      ContractCallWithTokenEvent.InputTuple,
      ContractCallWithTokenEvent.OutputTuple,
      ContractCallWithTokenEvent.OutputObject
    >;
    ContractCallWithToken: TypedContractEvent<
      ContractCallWithTokenEvent.InputTuple,
      ContractCallWithTokenEvent.OutputTuple,
      ContractCallWithTokenEvent.OutputObject
    >;

    "Executed(bytes32)": TypedContractEvent<
      ExecutedEvent.InputTuple,
      ExecutedEvent.OutputTuple,
      ExecutedEvent.OutputObject
    >;
    Executed: TypedContractEvent<
      ExecutedEvent.InputTuple,
      ExecutedEvent.OutputTuple,
      ExecutedEvent.OutputObject
    >;

    "GovernanceTransferred(address,address)": TypedContractEvent<
      GovernanceTransferredEvent.InputTuple,
      GovernanceTransferredEvent.OutputTuple,
      GovernanceTransferredEvent.OutputObject
    >;
    GovernanceTransferred: TypedContractEvent<
      GovernanceTransferredEvent.InputTuple,
      GovernanceTransferredEvent.OutputTuple,
      GovernanceTransferredEvent.OutputObject
    >;

    "MintLimiterTransferred(address,address)": TypedContractEvent<
      MintLimiterTransferredEvent.InputTuple,
      MintLimiterTransferredEvent.OutputTuple,
      MintLimiterTransferredEvent.OutputObject
    >;
    MintLimiterTransferred: TypedContractEvent<
      MintLimiterTransferredEvent.InputTuple,
      MintLimiterTransferredEvent.OutputTuple,
      MintLimiterTransferredEvent.OutputObject
    >;

    "OperatorshipTransferred(bytes)": TypedContractEvent<
      OperatorshipTransferredEvent.InputTuple,
      OperatorshipTransferredEvent.OutputTuple,
      OperatorshipTransferredEvent.OutputObject
    >;
    OperatorshipTransferred: TypedContractEvent<
      OperatorshipTransferredEvent.InputTuple,
      OperatorshipTransferredEvent.OutputTuple,
      OperatorshipTransferredEvent.OutputObject
    >;

    "TokenDeployed(string,address)": TypedContractEvent<
      TokenDeployedEvent.InputTuple,
      TokenDeployedEvent.OutputTuple,
      TokenDeployedEvent.OutputObject
    >;
    TokenDeployed: TypedContractEvent<
      TokenDeployedEvent.InputTuple,
      TokenDeployedEvent.OutputTuple,
      TokenDeployedEvent.OutputObject
    >;

    "TokenMintLimitUpdated(string,uint256)": TypedContractEvent<
      TokenMintLimitUpdatedEvent.InputTuple,
      TokenMintLimitUpdatedEvent.OutputTuple,
      TokenMintLimitUpdatedEvent.OutputObject
    >;
    TokenMintLimitUpdated: TypedContractEvent<
      TokenMintLimitUpdatedEvent.InputTuple,
      TokenMintLimitUpdatedEvent.OutputTuple,
      TokenMintLimitUpdatedEvent.OutputObject
    >;

    "TokenSent(address,string,string,string,uint256)": TypedContractEvent<
      TokenSentEvent.InputTuple,
      TokenSentEvent.OutputTuple,
      TokenSentEvent.OutputObject
    >;
    TokenSent: TypedContractEvent<
      TokenSentEvent.InputTuple,
      TokenSentEvent.OutputTuple,
      TokenSentEvent.OutputObject
    >;

    "Upgraded(address)": TypedContractEvent<
      UpgradedEvent.InputTuple,
      UpgradedEvent.OutputTuple,
      UpgradedEvent.OutputObject
    >;
    Upgraded: TypedContractEvent<
      UpgradedEvent.InputTuple,
      UpgradedEvent.OutputTuple,
      UpgradedEvent.OutputObject
    >;
  };
}
